ChatbotRAG API Documentation
Version: 1.0
Base URL: http://localhost:8000
Production: https://minhvtt-ChatbotRAG.hf.space/

üì° API Overview
Authentication
Currently: None (add JWT/API key if needed)

Content-Type
Request: application/json
Response: application/json (REST) or text/event-stream (SSE)
üóÇÔ∏è Table of Contents
Chat APIs
POST /chat
POST /chat/stream (SSE)
Session Management
GET /chat/history/{session_id}
POST /chat/clear-session
GET /chat/session/{session_id}
GET /chat/sessions
Scenario APIs
GET /scenarios
POST /scenarios/{scenario_id}/start
SSE Events Reference
üí¨ Chat APIs
POST /chat
Regular chat v·ªõi response tr·∫£ v·ªÅ ngay (non-streaming).

Request:

{
  "message": "gi√° v√© bao nhi√™u?",
  "session_id": "abc-123",        // optional, auto-create if null
  "user_id": "user_456",          // optional
  "use_rag": true,                // default: true
  "enable_tools": true,           // default: true
  "top_k": 3,                     // default: 3
  "score_threshold": 0.5,         // default: 0.5
  "temperature": 0.7,             // default: 0.7
  "system_message": "custom..."   // optional
}
Response:

{
  "response": "Hello üëã B·∫°n mu·ªën xem gi√° c·ªßa show n√†o?",
  "session_id": "abc-123",
  "mode": "scenario",             // scenario | rag
  "scenario_active": true,
  "timestamp": "2024-11-30T..."
}
Use Cases:

Regular chatbot interaction
Scenario-based conversations
RAG knowledge retrieval
Mid-scenario interruption (RAG while in scenario)
POST /chat/stream
Real-time streaming chat v·ªõi SSE (typing effect).

Request:

{
  "message": "gi√° v√© bao nhi√™u?",
  "session_id": "abc-123",
  "use_rag": true
}
Response: SSE Stream

event: status
data: ƒêang ph√¢n t√≠ch c√¢u h·ªèi...
event: metadata
data: {"session_id": "abc-123"}
event: token
data: Hello
event: token
data:  üëã 
event: token
data: B·∫°n
event: done
data: {"session_id": "abc-123", "timestamp": "..."}
Client Example (JavaScript):

const response = await fetch('/chat/stream', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    message: "gi√° v√© bao nhi√™u?",
    use_rag: true
  })
});
const reader = response.body.getReader();
const decoder = new TextDecoder();
while (true) {
  const {done, value} = await reader.read();
  if (done) break;
  const chunk = decoder.decode(value, {stream: true});
  const lines = chunk.split('\n');
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith('event: token')) {
      const data = lines[i + 1]?.substring(6);
      if (data) {
        displayToken(data); // Append to UI
      }
    }
  }
}
Use Cases:

Real-time "typing" effect
Progressive text display
Better perceived performance
Status updates during processing
üìö Session Management
GET /chat/history/{session_id}
L·∫•y to√†n b·ªô l·ªãch s·ª≠ chat c·ªßa 1 session.

Request:

GET /chat/history/abc-123?include_metadata=true
Response:

{
  "session_id": "abc-123",
  "messages": [
    {
      "role": "user",
      "content": "gi√° v√© bao nhi√™u?",
      "timestamp": "2024-11-30T10:00:00Z",
      "metadata": {
        "intent": "scenario:price_inquiry"
      }
    },
    {
      "role": "assistant",
      "content": "Hello üëã B·∫°n mu·ªën xem gi√°...",
      "timestamp": "2024-11-30T10:00:01Z",
      "metadata": {
        "mode": "scenario",
        "scenario_active": true
      }
    }
  ],
  "total_messages": 2
}
POST /chat/clear-session
X√≥a l·ªãch s·ª≠ chat c·ªßa 1 session.

Request:

POST /chat/clear-session?session_id=abc-123
Response:

{
  "success": true,
  "message": "Session abc-123 cleared successfully"
}
GET /chat/session/{session_id}
L·∫•y th√¥ng tin metadata c·ªßa session.

Request:

GET /chat/session/abc-123
Response:

{
  "session_id": "abc-123",
  "created_at": "2024-11-30T10:00:00Z",
  "updated_at": "2024-11-30T10:05:00Z",
  "message_count": 10,
  "metadata": {
    "user_agent": "api",
    "created_via": "hybrid_chat"
  }
}
GET /chat/sessions
L·∫•y danh s√°ch t·∫•t c·∫£ sessions (c√≥ filter).

Request:

GET /chat/sessions?user_id=user_123&limit=20&skip=0&sort_by=updated_at
Query Parameters:

user_id (optional): Filter by user
limit (default: 10, max: 100)
skip (default: 0)
sort_by (default: created_at, options: created_at, updated_at)
Response:

{
  "total": 50,
  "limit": 20,
  "skip": 0,
  "sessions": [
    {
      "session_id": "abc-123",
      "created_at": "2024-11-30T10:00:00Z",
      "updated_at": "2024-11-30T10:05:00Z",
      "message_count": 10,
      "user_id": "user_123"
    }
  ]
}
üé¨ Scenario APIs
GET /scenarios
L·∫•y danh s√°ch t·∫•t c·∫£ scenarios available.

Request:

GET /scenarios
Response:

{
  "total": 6,
  "scenarios": [
    {
      "scenario_id": "price_inquiry",
      "name": "H·ªèi gi√° v√©",
      "description": "T∆∞ v·∫•n gi√° v√© v√† g·ª≠i PDF b·∫£ng gi√°",
      "triggers": ["gi√° v√©", "bao nhi√™u", "ticket price"],
      "category": "sales",
      "priority": "high",
      "estimated_duration": "3min"
    },
    {
      "scenario_id": "post_event_feedback",
      "name": "H·∫≠u s·ª± ki·ªán ‚Äì Thu th·∫≠p feedback",
      "description": "ChƒÉm s√≥c kh√°ch sau s·ª± ki·ªán",
      "triggers": ["feedback", "ƒë√°nh gi√°"],
      "category": "engagement",
      "priority": "normal",
      "estimated_duration": "5min"
    }
  ]
}
Use Cases:

FE random pick scenario
Display scenario menu
Filter by category/priority
Proactive chat trigger
POST /scenarios/{scenario_id}/start
B·∫Øt ƒë·∫ßu 1 scenario (c√≥ th·ªÉ inject initial data).

Request (Simple):

POST /scenarios/price_inquiry/start
{
  "user_id": "user_123"
}
Request (With Initial Data):

POST /scenarios/post_event_feedback/start
{
  "initial_data": {
    "event_name": "H√≤a Nh·∫°c M√πa Xu√¢n",
    "event_date": "2024-11-29",
    "event_id": "evt_123"
  },
  "session_id": "abc-123",    // optional
  "user_id": "user_456"        // optional
}
Response:

{
  "session_id": "new-session-id",
  "scenario_id": "post_event_feedback",
  "message": "C·∫£m ∆°n b·∫°n ƒë√£ tham d·ª± *H√≤a Nh·∫°c M√πa Xu√¢n* h√¥m qua!",
  "scenario_active": true,
  "proactive": true
}
Use Cases:

Proactive engagement (random scenario)
Post-purchase follow-up
Exit intent rescue
Event-triggered scenarios
üîå SSE Events Reference
Event Types
Event	Purpose	Data Format	Example
status	Bot processing status	String	"ƒêang suy nghƒ©..."
token	Text chunk	String	"Hello"
metadata	Session/context info	JSON Object	{"session_id": "..."}
done	Stream completion	JSON Object	{"timestamp": "..."}
error	Error occurred	String	"Invalid request"
Event Flow
1. status     ‚Üí "ƒêang ph√¢n t√≠ch c√¢u h·ªèi..."
2. metadata   ‚Üí {"session_id": "abc-123"}
3. token      ‚Üí "Hello"
4. token      ‚Üí " üëã"
5. token      ‚Üí " B·∫°n"
6. token      ‚Üí " mu·ªën"
...
N. done       ‚Üí {"session_id": "abc-123", "timestamp": "..."}
Error Handling
Client-side:

reader.read().then(({done, value}) => {
  if (done) {
    console.log('Stream ended');
    return;
  }
  
  const chunk = decoder.decode(value);
  
  if (chunk.includes('event: error')) {
    const errorMsg = chunk.split('data: ')[1];
    handleError(errorMsg);
  }
});
Common Errors:

"Session not found" - Invalid session_id
"Scenario not found" - Invalid scenario_id
"Network timeout" - Connection lost
üéØ Common Use Cases
UC1: New Chat (No Session)
// User sends first message
const res = await fetch('/chat', {
  method: 'POST',
  body: JSON.stringify({
    message: "gi√° v√© bao nhi√™u?",
    use_rag: true
  })
});
const data = await res.json();
// Save session_id for future messages
localStorage.setItem('sessionId', data.session_id);
UC2: Continue Conversation
// User sends follow-up
const sessionId = localStorage.getItem('sessionId');
await fetch('/chat', {
  method: 'POST',
  body: JSON.stringify({
    message: "Show A",
    session_id: sessionId
  })
});
UC3: Streaming Chat with Typing Effect
const response = await fetch('/chat/stream', {
  method: 'POST',
  body: JSON.stringify({ message: "hello" })
});
const reader = response.body.getReader();
const decoder = new TextDecoder();
let botMessage = '';
while (true) {
  const {done, value} = await reader.read();
  if (done) break;
  const chunk = decoder.decode(value, {stream: true});
  const lines = chunk.split('\n');
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith('event: token')) {
      const token = lines[i + 1]?.substring(6);
      if (token) {
        botMessage += token;
        updateUI(botMessage); // Progressive update
      }
    }
  }
}
UC4: Random Proactive Scenario
// Get scenarios
const { scenarios } = await fetch('/scenarios').then(r => r.json());
// Random pick
const random = scenarios[Math.floor(Math.random() * scenarios.length)];
// Start scenario
const result = await fetch(`/scenarios/${random.scenario_id}/start`, {
  method: 'POST',
  body: JSON.stringify({ user_id: currentUser.id })
});
const { message, session_id } = await result.json();
// Display first message
chatUI.showMessage(message);
localStorage.setItem('sessionId', session_id);
UC5: Exit Intent with Context
document.addEventListener('mouseout', (e) => {
  if (e.clientY < 10) {
    fetch('/scenarios/exit_intent_rescue/start', {
      method: 'POST',
      body: JSON.stringify({
        initial_data: {
          cart_total: getCartTotal(),
          items_count: getCartCount()
        },
        user_id: currentUser.id
      })
    });
  }
});
UC6: Post-Event Feedback
// Backend triggers after user check-out
async function triggerFeedback(userId, eventId) {
  const event = await db.events.findById(eventId);
  
  await fetch('/scenarios/post_event_feedback/start', {
    method: 'POST',
    body: JSON.stringify({
      initial_data: {
        event_name: event.name,
        event_date: event.date,
        event_id: eventId
      },
      user_id: userId
    })
  });
}
üîß Rate Limiting
Current: None
Recommended: 100 requests/minute per user

üåê CORS
Allowed Origins: * (configure for production)
Allowed Methods: GET, POST, OPTIONS
Allowed Headers: Content-Type, Authorization

üìä Response Codes
Code	Meaning	Example
200	Success	Chat response returned
404	Not Found	Session/Scenario not found
500	Server Error	Internal processing error

üìù Notes
Session auto-expires after 7 days of inactivity
Max conversation history: 10 messages (sliding window)
SSE connections timeout after 30s idle
Scenario state persists across sessions
Last Updated: 2024-11-30
Maintainer: ChatbotRAG Team